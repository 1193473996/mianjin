 # JUC
## volatile
1、写volatile变量会强制写回主存
2、读volatile变量会清除线程缓存，强制到主存读取
3、禁止重排序
原理为内存屏障：是一个同步点，使同步点前的所有读写操作都执行完成后才执行此点之后的操作，并且操作之前的写操作都会写回主存
读屏障：读指令之前，让工作内存缓存失效；
写屏障：写指令之后，工作内存写回主存；
底层加ACC_Volatile关键字，Unsafe.class
loadload：读1读2间，保证读1后再读2
loadstore：读1写2，写2前保证读1已完成
storestore：写1写2，写2前保证写1完成
storeload：写1读2，读2前保证写1完成

volatile读后+loadload、loadstore屏障
volatile写前+storestore，后+storeload屏障

懒汉式单例在对象上+volatile关键字
目的是防止指令重排序，因为singleton=new xx()是复合操作，包括1）申请内存；2）初始化对象；3）设置singleton指向内存；
其中2）3）可能会被重排序，导致其他线程取到null的对象；


# CAS
底层是CPU的原子指令
Unsafe类的本地方法，compareAndSwapInt()
方法先获取变量值，如果值与期望值不同则自旋（底层是do-while循环），否则更新值；
汇编层级会禁止变量两侧的指令优化，使用cmpxchg指令更新；
AtomicReference<Object>可以定义任何对象的原子类型，调用CAS方法；
缺点：
1）CAS长时间不成功，自旋CPU空转
2）ABA问题：线程1取出A，线程2取出并改写为B，又改回A，线程1CAS时成功；虽成功但过程有问题；（使用版本号记录更新流水记录，更新时校验版本号，AtomicStampedReference）

# AtomicIntegerFieldUpdater
以线程安全的方式操作非线程安全对象内某些字段，相较于synchronized的对象锁，该方法只锁局部
操作对象修饰为public volatile，通过反射

#ThreadLocal
底层原理ThreadLocal并不存储值，只是作为key从ThreadLocalMap获取value，static的ThreadLocalMap保存，ThreadLocal为key，任意对象Entry为value
底层弱引用，假设如果是强引用，线程结束没回收的将导致内存泄漏（ThreadLocal引用置为null后，Map中存key=null，value有对象，线程池场景存在强引用链，无法GC回收）；
remove()方法会查找key=null的Entry并清除


强：Reference，最常见，new出来的，GC不回收，显式置为null才可能被回收；
软：SoftReference，内存充足不回收，不够才回收，高速缓存场景用；
弱：WeakReference，只要GC就回收；
（大图片场景，图片缓存Map中K-V，V存软引用，不足时自动回收）
虚：PhantomReference，必须和引用队列ReferenceQueue同时使用，单独虚引用无意义（get方法总是返回null），使用场景即对象被回收前的通知


# synchronized锁升级
无锁-->偏向锁-->轻量级锁-->重量级锁
对象头MarkWord三个byte位标识
早期synchronized加锁需要用户态和内核态切换，操作系统介入进行线程唤醒或阻塞
知识点|无锁|偏向锁|轻量级锁|重量级锁
存储|X|存储偏向的线程ID|存储指向线程栈中Lock Record的指针|存储指向堆中monitor对象的指针
markword标识|000|101|
场景|无|一个线程访问，偏向锁偏向于第一个访问锁的线程|
处理流程||判断当前线程ID与偏向线程ID是否一致，一致直接进入同步块，无需CAS更新对象头；不是则发生竞争CAS替换偏向线程ID；CAS更新成功则竞争成功；竞争失败可能升级为轻量级锁；|

